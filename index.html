<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dance Master Pro 2026</title>
    <style>
        :root { --blue: #007AFF; --red: #FF3B30; --green: #34C759; --yellow: #FFCC00; }
        body { 
            background-color: black; color: white; 
            font-family: -apple-system, sans-serif;
            margin: 0; overflow: hidden; height: 100vh;
            display: flex; flex-direction: column;
        }
        #top-bar { padding: 20px; display: flex; justify-content: space-between; align-items: center; background: #111; }
        #main-ui { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; }
        
        /* Tanz Anzeige */
        #dance-name { font-size: clamp(3rem, 15vw, 10rem); font-weight: 900; text-transform: uppercase; line-height: 0.9; margin: 10px 0; }
        #meter-info { font-size: 2rem; font-weight: bold; color: var(--blue); letter-spacing: 10px; }
        #status-msg { color: var(--yellow); font-size: 1rem; height: 1.2rem; margin-bottom: 20px; }

        /* BPM & Signal */
        #footer { padding: 30px; display: flex; justify-content: space-around; width: 100%; border-top: 1px solid #333; background: #050505; }
        .stat-value { font-size: 4rem; font-weight: bold; font-family: monospace; }
        .stat-label { font-size: 0.8rem; color: #888; text-transform: uppercase; }

        /* Haxen (F√º√üe) - Standard aus */
        #footprints { display: none; gap: 80px; margin: 30px 0; }
        .foot { width: 60px; height: 100px; opacity: 0.1; transition: opacity 0.1s; }

        button { 
            background: var(--green); border: none; color: white; padding: 15px 30px; 
            border-radius: 12px; font-weight: bold; font-size: 1.2rem; cursor: pointer;
        }
        button.stop { background: var(--red); }
        .settings-btn { background: #333; padding: 10px; border-radius: 50%; width: 50px; height: 50px; border: none; color: white; cursor: pointer; }

        /* Modal Settings */
        #settings-modal { 
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); z-index: 100; padding: 30px; box-sizing: border-box;
        }
        input { width: 100%; background: #222; border: 1px solid #444; color: white; padding: 15px; border-radius: 10px; margin-bottom: 20px; }
    
        /* Help / Video overlay */
        .overlay{
            display:none; position:fixed; inset:0;
            background:rgba(0,0,0,0.85);
            z-index:120;
            padding: 18px;
            box-sizing:border-box;
        }
        .sheet{
            max-width: 980px; margin: 0 auto;
            background: rgba(255,255,255,0.06);
            border:1px solid rgba(255,255,255,0.12);
            border-radius: 16px;
            overflow:hidden;
        }
        .sheetHeader{
            display:flex; justify-content:space-between; align-items:center;
            padding:14px;
            border-bottom:1px solid rgba(255,255,255,0.10);
            background: rgba(0,0,0,0.35);
        }
        .sheetTitle{ font-weight:900; font-size: 1.1rem; }
        .sheetTabs{ display:flex; gap:8px; flex-wrap:wrap; padding: 12px 14px; border-bottom:1px solid rgba(255,255,255,0.10); }
        .tabBtn{ background: rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.12); color:#fff; padding:8px 10px; border-radius: 12px; cursor:pointer; font-weight:700; }
        .tabBtn.active{ background: var(--blue); border-color: rgba(255,255,255,0.0); }
        .sheetBody{ padding: 14px; max-height: 78vh; overflow:auto; }

        details.danceCard{
            border:1px solid rgba(255,255,255,0.12);
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            margin: 10px 0;
            overflow:hidden;
        }
        details.danceCard > summary{
            cursor:pointer; list-style:none;
            display:flex; justify-content:space-between; align-items:center;
            padding: 12px 12px;
            font-weight: 900;
        }
        details.danceCard > summary::-webkit-details-marker{ display:none; }
        .figRow{
            padding: 10px 12px 12px;
            border-top:1px solid rgba(255,255,255,0.08);
        }
        .figHead{ display:flex; justify-content:space-between; gap:10px; align-items:center; flex-wrap:wrap; }
        .figName{ font-weight:800; }
        .miniBtn{ background: rgba(255,255,255,0.10); border:1px solid rgba(255,255,255,0.12); color:#fff; padding:8px 10px; border-radius: 12px; cursor:pointer; font-weight:800; }
        .miniBtn.blue{ background: var(--blue); border-color: transparent; }
        .playerWrap{ display:none; margin-top: 10px; }
        .playerWrap.active{ display:block; }
        .videoEl{ width:100%; border-radius: 14px; border:1px solid rgba(255,255,255,0.12); background:#000; }
        .playerBar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:8px; }
        .hint{ font-size: 0.8rem; opacity:0.75; }

        /* Tap tempo pads */
        .pads{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top: 12px; }
        .pad{
            border-radius: 16px;
            border:1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            height: 140px;
            display:flex; align-items:center; justify-content:center;
            font-weight: 900;
            user-select:none;
            -webkit-user-select:none;
            touch-action: manipulation;
        }
        .pad:active{ transform: translateY(1px); }
        .tapOut{
            margin-top: 12px;
            border:1px solid rgba(255,255,255,0.12);
            border-radius: 14px;
            background: rgba(255,255,255,0.04);
            padding: 12px;
        }

        /* Calibrated display */
        #dance-name.calibrated{ color: var(--green) !important; text-shadow: 0 0 22px rgba(52,199,89,0.25); }

        /* History table */
        table{ width:100%; border-collapse: collapse; }
        th, td{ border-bottom: 1px solid rgba(255,255,255,0.08); padding: 10px 6px; font-size: 0.9rem; }
        th{ text-align:left; opacity: 0.75; font-size: 0.75rem; letter-spacing: 0.08em; text-transform:uppercase; }

        /* Stars row - portrait puts stars on its own line */
        .ratingRow{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
        .stars{ display:flex; gap:6px; }
        .star{ font-size: 1.4rem; cursor:pointer; opacity:0.55; }
        .star.on{ opacity:1; }
        @media (max-width: 520px){
            .ratingRow{ flex-direction: column; align-items: stretch; }
            .stars{ justify-content:flex-start; }
        }

    </style>
</head>
<body>

<div id="top-bar">
    <div id="diagnose" style="font-size: 0.8rem; color: #555;">Pegel: 0.0000</div>
    <button id="start-btn" onclick="toggleEngine()">START</button>
    <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è</button>
    <button class="settings-btn" onclick="openHelp()" title="Video-Hilfe">?</button>
</div>

<div id="main-ui">
    <div id="status-msg">BEREIT</div>
    <h1 id="dance-name">---</h1>
    <div id="meter-info">---</div>

    <div id="footprints">
        <div id="foot-left" class="foot" style="color: var(--yellow); transform: rotate(-15deg);">
            <svg viewBox="0 0 200 400"><path d="M50 0C20 0 0 50 0 150s20 250 50 250 50-50 50-150S80 0 50 0z"/></svg>
        </div>
        <div id="foot-right" class="foot" style="color: var(--red); transform: rotate(15deg);">
            <svg viewBox="0 0 200 400"><path d="M50 0C20 0 0 50 0 150s20 250 50 250 50-50 50-150S80 0 50 0z"/></svg>
        </div>
    </div>
</div>

<div id="footer">
    <div style="text-align: center;">
        <div id="bpm-val" class="stat-value">0</div>
        <div class="stat-label">BPM</div>
    </div>
    <div style="text-align: center; max-width: 50%;">
        <div id="song-display" style="font-size: 1.2rem; font-weight: bold; overflow: hidden; white-space: nowrap; text-overflow: ellipsis;">Kein Lied</div>
        <div class="stat-label">Automatische Erkennung</div>
    </div>
</div>

<div id="settings-modal">
    <h2>Einstellungen</h2>
    <label>OpenAI API Key (Klartext)</label>
    <input type="text" id="api-key-input" placeholder="sk-...">
    
    <label>Mikrofon Empfindlichkeit</label>
    <input type="range" id="gain-slider" min="1" max="100" value="20">
    
    <label>Optionen</label>
    <button onclick="toggleHaxen()" style="background: #444; width: 100%; margin-bottom: 20px;">F√º√üe (Haxen) AN/AUS</button>
    <button onclick="testAI()" style="background: var(--blue); width: 100%; margin-bottom: 20px;">Verbindung Testen</button>
    <button onclick="toggleCalibration()" style="background: #444; width: 100%; margin-bottom: 10px;">Kalibrieren (KI+Shazam)</button>
    <button onclick="saveCalibration()" style="background: #222; width: 100%; margin-bottom: 10px;">Kalibrierung speichern</button>
    <button onclick="loadCalibration()" style="background: #222; width: 100%; margin-bottom: 20px;">Kalibrierung laden</button>
    
    <button onclick="closeSettings()" style="width: 100%; background: var(--green);">SPEICHERN & FERTIG</button>
</div>


<script>
/* ===========================
   Tanz das ‚Äì Audio/AI/Video Help Module
   - Segment-loop help videos (ChaCha)
   - Better local tempo/meter estimation with normalization
   - Calibration against AI (target BPM + meter)
   - Stable switching (3 consecutive 3s windows)
   - History: date,title,dance,bpm,meter + rating stars
   - Tap-tempo fallback (no audio)
   =========================== */

let audioCtx, analyser, source, processor;
let isRunning = false;

// --- UI handles
const UI = {
  diagnose: () => document.getElementById('diagnose'),
  btnStart: () => document.getElementById('start-btn'),
  status: () => document.getElementById('status-msg'),
  dance: () => document.getElementById('dance-name'),
  meter: () => document.getElementById('meter-info'),
  bpm: () => document.getElementById('bpm-val'),
  song: () => document.getElementById('song-display'),
  gain: () => document.getElementById('gain-slider'),
  apiKey: () => document.getElementById('api-key-input'),
};

// --- Dance profiles (BPM scale = what we display in app, e.g. ChaCha ~ 30‚Äì32)
const DANCE_PROFILES = [
  { name: "Cha-Cha", meter: "4/4", bpmMin: 28, bpmMax: 36 },
  { name: "Salsa",   meter: "4/4", bpmMin: 38, bpmMax: 55 }, // rough (bar-ish)
  { name: "Rumba",   meter: "4/4", bpmMin: 22, bpmMax: 30 },
  { name: "Tango",   meter: "4/4", bpmMin: 30, bpmMax: 38 },
  { name: "Wiener Walzer", meter: "3/4", bpmMin: 50, bpmMax: 65 }, // bar-ish
  { name: "Langsamer Walzer", meter: "3/4", bpmMin: 28, bpmMax: 40 },
];

// --- Calibration (stored in localStorage)
const CAL_KEY = "tanz_calibration_v1";
let CAL = loadCalInternal() || {
  calibrated: false,
  bpmDivisor: 4,        // rawBpm / divisor -> appBpm
  gateK: 2.2,           // dynamic threshold factor
  minIntervalMs: 220,   // ignore too-fast onsets
  targetMeter: null,    // "3/4" or "4/4" from AI
  lastAi: null          // {title,dance,bpm,meter,accent}
};

// --- Switching stability
let windowBuf = []; // last windows {bpm,meter}
let stable = { bpm: null, meter: null, dance: "---" };

// --- Energy stats for dynamic gate
let rmsMean = 0, rmsVar = 0, rmsN = 0;

// --- Beat times (ms) within moving window
let beatTimes = [];
let lastOnsetMs = 0;

// --- 3-second window tick
let winStart = performance.now();
let lastWindowEval = performance.now();

// --- History
const HIST_KEY = "tanz_history_v1";
let HISTORY = loadHistoryInternal();

// --- Rating
const RATING_KEY = "tanz_rating_v1";
let rating = Number(localStorage.getItem(RATING_KEY) || 0);

// --- Tap tempo
let tapTimes = [];
let tapMeter = "4/4";

// --- Help video DB (ChaCha) ‚Äì from your VideoPad sequence (.vpj)
const VIDEO_DB = [
  {
    id: "chacha",
    title: "Cha Cha",
    src: "/media/chacha.mp4",
    figures: [
      { id:"timestep",    name:"Grundschritt am Platz / Timestep",        start: 0.000,   end: 17.551 },
      { id:"wiege",       name:"Grundschritt mit Wiegeschritt",           start: 17.551,  end: 30.484 },
      { id:"damensolo",   name:"Damensolo",                               start: 30.484,  end: 52.884 },
      { id:"newyorker",   name:"New Yorker/Promenade",                    start: 52.884,  end: 80.303 },
      { id:"hand2hand",   name:"Hand to Hand",                            start: 80.303,  end: 103.503 },
      { id:"shoulder",    name:"Shoulder to Shoulder",                    start: 103.503, end: 123.370 },
      { id:"fan_alemana", name:"Fan & Alemana",                           start: 123.370, end: 141.970 },
      { id:"hockeystick", name:"Hockeystick & Open Hip Twist",            start: 141.970, end: 169.437 },
      { id:"aida",        name:"Aida",                                    start: 169.437, end: 197.170 },
    ]
  }
];

// --- Inline help video player (single instance)
const HelpPlayer = {
  video: null,
  seg: null,
  guard: false,
  wrap: null,

  ensure(){
    if (this.video) return;
    const v = document.createElement("video");
    v.className = "videoEl";
    v.controls = true;
    v.preload = "metadata";
    v.setAttribute("playsinline","");
    v.setAttribute("webkit-playsinline","");
    this.video = v;

    v.addEventListener("timeupdate", () => {
      if (!this.seg || this.guard) return;
      if (v.currentTime >= this.seg.end - 0.01) {
        this.guard = true;
        v.currentTime = this.seg.start + 0.02;
        v.play().catch(()=>{});
        setTimeout(()=>this.guard=false, 80);
      }
    });

    v.addEventListener("seeking", () => {
      if (!this.seg || this.guard) return;
      if (v.currentTime < this.seg.start || v.currentTime > this.seg.end) {
        this.guard = true;
        v.currentTime = this.seg.start + 0.02;
        setTimeout(()=>this.guard=false, 80);
      }
    });
  },

  playSegment(src, start, end, wrapEl){
    this.ensure();

    // move player
    if (this.wrap && this.wrap !== wrapEl){
      this.wrap.classList.remove("active");
      this.wrap.innerHTML = "";
    }
    this.wrap = wrapEl;
    this.wrap.classList.add("active");
    this.wrap.innerHTML = "";

    // bar
    const bar = document.createElement("div");
    bar.className = "playerBar";

    const btnFs = document.createElement("button");
    btnFs.className = "miniBtn blue";
    btnFs.textContent = "Vollbild";
    btnFs.onclick = () => requestFullscreenSafe(this.video);

    const btnStop = document.createElement("button");
    btnStop.className = "miniBtn";
    btnStop.textContent = "Stop";
    btnStop.onclick = () => this.stop();

    const hint = document.createElement("div");
    hint.className = "hint";
    hint.textContent = `Loop: ${fmtTime(start)} ‚Äì ${fmtTime(end)}`;

    bar.append(btnFs, btnStop);
    this.wrap.append(this.video, bar, hint);

    // src
    if (this.video.dataset.src !== src){
      this.video.dataset.src = src;
      this.video.src = src;
      this.video.load();
    }

    this.seg = { start:Number(start), end:Number(end) };
    this.guard = true;
    this.video.currentTime = this.seg.start + 0.02;
    this.video.play().catch(()=>{});
    setTimeout(()=>this.guard=false, 140);
  },

  stop(){
    this.seg = null;
    this.guard = true;
    try { this.video.pause(); } catch(e){}
    if (this.wrap){
      this.wrap.classList.remove("active");
      this.wrap.innerHTML = "";
    }
    this.wrap = null;
    setTimeout(()=>this.guard=false, 120);
  }
};

// ========== Boot: parse song from URL + load UI
window.onload = () => {
  const params = new URLSearchParams(window.location.search);
  const song = params.get('song');
  if (song) {
    UI.song().innerText = song;
    askAI(song);
  }
  UI.apiKey().value = localStorage.getItem('api_key') || '';
  // NTFY topic (from URL ?t= or localStorage)
  const t = params.get('t') || localStorage.getItem('ntfy_topic') || '';
  const topicInput = document.getElementById('ntfy-topic');
  if (topicInput) topicInput.value = t;
  const autoCal = document.getElementById('auto-cal');
  if (autoCal) autoCal.checked = (localStorage.getItem('auto_cal') === '1');

  if (t) startNtfy(t);

  renderHelpVideos();
  renderStars();
  renderHistory();
  applyCalibratedStyle();
};

// ========== Settings modal
function openSettings() { document.getElementById('settings-modal').style.display = 'block'; }
function closeSettings() {
  localStorage.setItem('api_key', UI.apiKey().value);

  const t = (document.getElementById('ntfy-topic')?.value || '').trim();
  if (t) localStorage.setItem('ntfy_topic', t);
  else localStorage.removeItem('ntfy_topic');

  const auto = document.getElementById('auto-cal')?.checked ? '1' : '0';
  localStorage.setItem('auto_cal', auto);

  document.getElementById('settings-modal').style.display = 'none';
}
function toggleHaxen() {
  // kept for compatibility; visuals can stay off
  const fp = document.getElementById('footprints');
  const show = fp.style.display !== 'flex';
  fp.style.display = show ? 'flex' : 'none';
}

// ========== Help overlay
function openHelp(){
  document.getElementById("help-overlay").style.display = "block";
  showHelpTab("videos");
}
function closeHelp(){
  document.getElementById("help-overlay").style.display = "none";
  HelpPlayer.stop();
}
function overlayBgClose(e){
  if (e.target && e.target.id === "help-overlay") closeHelp();
}
function showHelpTab(which){
  const vids = document.getElementById("helpBodyVideos");
  const tap  = document.getElementById("helpBodyTap");
  const hist = document.getElementById("helpBodyHistory");

  vids.style.display = (which==="videos") ? "block" : "none";
  tap.style.display  = (which==="tap")    ? "block" : "none";
  hist.style.display = (which==="history")? "block" : "none";

  document.getElementById("tabVideos").classList.toggle("active", which==="videos");
  document.getElementById("tabTap").classList.toggle("active", which==="tap");
  document.getElementById("tabHistory").classList.toggle("active", which==="history");
}

// ========== Audio engine (improved)
async function toggleEngine() {
  if (isRunning) { location.reload(); return; } // keep your original quick-stop behavior
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    source = audioCtx.createMediaStreamSource(stream);

    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;

    processor = audioCtx.createScriptProcessor(2048, 1, 1);

    source.connect(analyser);
    analyser.connect(processor);
    processor.connect(audioCtx.destination);

    // reset
    beatTimes = [];
    rmsMean = 0; rmsVar = 0; rmsN = 0;
    lastOnsetMs = 0;
    windowBuf = [];
    stable = { bpm: null, meter: null, dance: "---" };
    winStart = performance.now();
    lastWindowEval = performance.now();

    processor.onaudioprocess = () => {
      // get time domain data
      const data = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(data);

      // RMS
      let sum = 0;
      for (let i=0;i<data.length;i++) sum += data[i]*data[i];
      const rms = Math.sqrt(sum / data.length);

      // update running stats (Welford-ish)
      rmsN++;
      const delta = rms - rmsMean;
      rmsMean += delta / rmsN;
      rmsVar += delta * (rms - rmsMean);

      const rmsStd = (rmsN > 1) ? Math.sqrt(rmsVar / (rmsN - 1)) : 0;
      const gate = rmsMean + (CAL.gateK * rmsStd);

      // "Sensitivity" via gain-slider: higher slider => easier to trigger
      // we invert it into gateK bias (small tweak per sample)
      const gain = Number(UI.gain().value || 20);
      const sens = 1.25 - Math.min(0.9, gain/100);  // 1.25..0.35
      const dynGate = gate * sens;

      UI.diagnose().innerText = "Signal: " + rms.toFixed(5);

      const nowMs = performance.now();
      if (rms > dynGate && (nowMs - lastOnsetMs) > CAL.minIntervalMs) {
        beatTimes.push(nowMs);
        // keep last ~10s
        const cutoff = nowMs - 10000;
        while (beatTimes.length && beatTimes[0] < cutoff) beatTimes.shift();
        lastOnsetMs = nowMs;
      }

      // evaluate every 3 seconds
      if (nowMs - lastWindowEval >= 3000) {
        evalWindow(nowMs);
        lastWindowEval = nowMs;
      }
    };

    isRunning = true;
    UI.btnStart().innerText = "STOP";
    UI.btnStart().classList.add('stop');
    UI.status().innerText = "ANALYSE L√ÑUFT...";
  } catch (e) {
    alert("Mic-Zugriff fehlt!");
  }
}

function evalWindow(nowMs){
  // need enough beats
  if (beatTimes.length < 6) return;

  // intervals (ms) in last 3s
  const wStart = nowMs - 3000;
  const times = beatTimes.filter(t => t >= wStart);
  if (times.length < 5) return;

  const intervals = [];
  for (let i=1;i<times.length;i++) intervals.push(times[i] - times[i-1]);
  intervals.sort((a,b)=>a-b);
  const med = intervals[Math.floor(intervals.length/2)];
  if (!isFinite(med) || med <= 0) return;

  const rawBpm = 60000 / med;

  // Normalize BPM to your app-scale BPM (e.g. 120 raw -> 30 app by divisor 4)
  const { bpm: appBpm, divisor } = normalizeBpm(rawBpm);

  // Meter guess: simple bar-accent heuristic on beat strengths (approx by RMS peaks density)
  const meterGuess = guessMeterFromPattern(times, divisor);

  UI.bpm().innerText = String(Math.round(appBpm));
  UI.meter().innerText = meterGuess + " TAKT";

  // choose dance (local) unless AI locked it
  const localDance = pickDance(appBpm, meterGuess);

  // stability rule: once calibrated, only switch if 3 windows in a row disagree
  const win = { bpm: Math.round(appBpm), meter: meterGuess, dance: localDance };
  windowBuf.push(win);
  if (windowBuf.length > 3) windowBuf.shift();

  if (CAL.calibrated) {
    maybeStabilize(win);
  } else {
    applyStable(win);
  }
}

function normalizeBpm(rawBpm){
  // If calibrated: keep divisor fixed to match your environment
  if (CAL.calibrated && CAL.bpmDivisor) {
    return { bpm: rawBpm / CAL.bpmDivisor, divisor: CAL.bpmDivisor };
  }

  // Otherwise: pick divisor 1..4 that best fits *any* profile range
  const candidates = [1,2,3,4].map(d => ({ d, bpm: rawBpm/d }));
  let best = candidates[0], bestScore = Infinity;

  for (const c of candidates){
    let score = 9999;
    for (const p of DANCE_PROFILES){
      const inRange = (c.bpm >= p.bpmMin && c.bpm <= p.bpmMax);
      const dist = inRange ? 0 : Math.min(Math.abs(c.bpm - p.bpmMin), Math.abs(c.bpm - p.bpmMax));
      score = Math.min(score, dist);
    }
    if (score < bestScore) { bestScore = score; best = c; }
  }
  return { bpm: best.bpm, divisor: best.d };
}

function guessMeterFromPattern(times, divisor){
  // If AI told us meter and we're calibrated: trust it (environment-specific)
  if (CAL.calibrated && CAL.targetMeter) return CAL.targetMeter;

  // Lightweight heuristic: compare 3 vs 4 bar grouping stability.
  // We take beat indices and assume "bars" are 3 or 4 beats at *app scale*.
  // If divisor=4, raw beat is quarter; app beat is bar -> we don't have enough info; fallback to tempo range.
  // So: if appBpm looks like waltz ranges, pick 3/4; else 4/4.
  const lastBpm = Number(UI.bpm().innerText || 0);
  // waltz-ish
  if (lastBpm >= 28 && lastBpm <= 65){
    // ambiguous; use raw tempo as tie-breaker: very steady fast raw often waltz? hmm.
  }
  // Use dance profile proximity
  let best3 = Infinity, best4 = Infinity;
  for (const p of DANCE_PROFILES){
    if (p.meter==="3/4") best3 = Math.min(best3, rangeDist(lastBpm, p.bpmMin, p.bpmMax));
    if (p.meter==="4/4") best4 = Math.min(best4, rangeDist(lastBpm, p.bpmMin, p.bpmMax));
  }
  return (best3 < best4) ? "3/4" : "4/4";
}

function rangeDist(x, lo, hi){
  if (x>=lo && x<=hi) return 0;
  return Math.min(Math.abs(x-lo), Math.abs(x-hi));
}

function pickDance(bpm, meter){
  // prefer calibrated AI dance if present
  if (CAL.calibrated && CAL.lastAi && CAL.lastAi.dance) return CAL.lastAi.dance;

  // otherwise pick best profile
  let best = { name: "---", score: Infinity };
  for (const p of DANCE_PROFILES){
    if (p.meter !== meter) continue;
    const dist = rangeDist(bpm, p.bpmMin, p.bpmMax);
    if (dist < best.score) best = { name: p.name, score: dist };
  }
  // fallback if none matches meter
  if (best.name==="---"){
    for (const p of DANCE_PROFILES){
      const dist = rangeDist(bpm, p.bpmMin, p.bpmMax) + (p.meter===meter?0:2);
      if (dist < best.score) best = { name: p.name, score: dist };
    }
  }
  return best.name;
}

function maybeStabilize(win){
  if (stable.bpm == null){
    applyStable(win);
    return;
  }
  if (windowBuf.length < 3) return;

  const allDiff = windowBuf.every(w =>
    (Math.abs(w.bpm - stable.bpm) >= 3) || (w.meter !== stable.meter)
  );

  if (allDiff){
    applyStable(win);
  } else {
    // keep current stable display
    UI.dance().innerText = stable.dance;
    UI.meter().innerText = (stable.meter || win.meter) + " TAKT";
    UI.bpm().innerText = String(stable.bpm ?? win.bpm);
  }
}

function applyStable(win){
  stable = { bpm: win.bpm, meter: win.meter, dance: win.dance };
  UI.dance().innerText = stable.dance;
}

// ========== AI (must return dance+bpm+meter+accent)
async function askAI(title) {
  const key = localStorage.getItem('api_key');
  if (!key) return;

  UI.status().innerText = "KI ANALYSIERT...";
  try {
    const prompt =
`Analysiere den Songtitel: "${title}".
Gib ausschlie√ülich ein JSON-Objekt zur√ºck, ohne Text davor/danach, im Format:
{"title":"...","dance":"...","bpm":<zahl>,"meter":"3/4|4/4","accent":"kurz"}

Regeln:
- bpm = so wie sie in einer Tanz-App angezeigt werden soll (z.B. Cha-Cha ca. 30-32 bei 4/4).
- meter = "3/4" oder "4/4".
- dance = konkreter Tanzname (z.B. "Cha-Cha", "Salsa", "Wiener Walzer", ...).
- accent: 1 kurzer Hinweis auf Betonung (z.B. "1 stark, 2-3 weich").`;

    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${key}`},
      body: JSON.stringify({
        model: "gpt-4o-mini",
        messages: [{role: "user", content: prompt}],
        max_tokens: 120
      })
    });

    const data = await resp.json();
    const raw = (data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) ? data.choices[0].message.content.trim() : "";

    const obj = safeJson(raw);
    if (!obj || !obj.dance) throw new Error("Bad AI JSON");

    // store
    CAL.lastAi = {
      title: obj.title || title,
      dance: (obj.dance || "").trim(),
      bpm: Number(obj.bpm) || null,
      meter: (obj.meter || "").trim(),
      accent: (obj.accent || "").trim()
    };

    // show AI dance immediately, but if calibrated we keep stable switching logic on local windows
    UI.dance().innerText = CAL.lastAi.dance;
    UI.status().innerText = "‚ú® KI BEST√ÑTIGT";

    // Auto-calibration (optional)
    if (localStorage.getItem("auto_cal") === "1") {
      // ensure calibration is ON and aligned to AI
      if (!CAL.calibrated) {
        try { CAL.calibrated = false; } catch(e){}
        toggleCalibration();
      } else {
        // refresh target meter/divisor using the latest AI
        CAL.targetMeter = CAL.lastAi.meter;
        persistCal();
        applyCalibratedStyle();
      }
    }

    // update history
    pushHistory({
      date: new Date().toISOString(),
      title: CAL.lastAi.title || title,
      dance: CAL.lastAi.dance,
      bpm: CAL.lastAi.bpm ?? Number(UI.bpm().innerText || 0),
      meter: CAL.lastAi.meter || (UI.meter().innerText.includes("3/4") ? "3/4" : "4/4")
    });

  } catch (e) {
    UI.status().innerText = "KI FEHLER";
  }
}

function safeJson(s){
  try { return JSON.parse(s); } catch(e){}
  // try to extract first {...}
  const m = s.match(/\{[\s\S]*\}/);
  if (!m) return null;
  try { return JSON.parse(m[0]); } catch(e){}
  return null;
}

// ========== Calibration
function toggleCalibration(){
  // Needs AI result as target
  if (!CAL.lastAi || !CAL.lastAi.bpm || !CAL.lastAi.meter){
    alert("Zuerst Song/KI-Ergebnis holen (Songtitel via Shortcut/URL oder manuell).");
    return;
  }

  CAL.calibrated = !CAL.calibrated;

  if (CAL.calibrated){
    // choose divisor that maps current raw bpm to AI bpm
    // We use current displayed bpm estimate if available, else approximate from beatTimes
    const currentBpm = Number(UI.bpm().innerText || 0);
    // try to infer divisor from raw bpm if possible: assume rawBpm is around 4x app bpm (often)
    // We'll use median interval from latest window if available:
    let rawGuess = null;
    if (beatTimes.length >= 6){
      const nowMs = performance.now();
      const wStart = nowMs - 3000;
      const times = beatTimes.filter(t => t >= wStart);
      if (times.length >= 5){
        const intervals = [];
        for (let i=1;i<times.length;i++) intervals.push(times[i]-times[i-1]);
        intervals.sort((a,b)=>a-b);
        const med = intervals[Math.floor(intervals.length/2)];
        rawGuess = 60000/med;
      }
    }
    const target = Number(CAL.lastAi.bpm);
    const candidates = [1,2,3,4].map(d => ({d, bpm: (rawGuess|| (target*4)) / d}));
    let best = candidates[0], bestDist = Infinity;
    for (const c of candidates){
      const dist = Math.abs(c.bpm - target);
      if (dist < bestDist) { bestDist = dist; best = c; }
    }
    CAL.bpmDivisor = best.d;
    CAL.targetMeter = CAL.lastAi.meter;
    UI.status().innerText = "‚úÖ KALIBRIERT";
  } else {
    UI.status().innerText = "KALIBRIERUNG AUS";
  }

  persistCal();
  applyCalibratedStyle();
}

function applyCalibratedStyle(){
  UI.dance().classList.toggle("calibrated", !!CAL.calibrated);
}

function saveCalibration(){
  persistCal();
  alert("Kalibrierung gespeichert ‚úÖ");
}
function loadCalibration(){
  const loaded = loadCalInternal();
  if (!loaded){
    alert("Keine Kalibrierung gefunden.");
    return;
  }
  CAL = loaded;
  applyCalibratedStyle();
  UI.status().innerText = CAL.calibrated ? "‚úÖ KALIBRIERT" : "BEREIT";
  alert("Kalibrierung geladen ‚úÖ");
}

// ========== NTFY (Watch/Shortcut feed)
let ntfyEv = null;

function startNtfy(topic){
  try{
    if (ntfyEv) { ntfyEv.close(); ntfyEv = null; }
    ntfyEv = new EventSource(`https://ntfy.sh/${encodeURIComponent(topic)}/sse`);
    UI.status().innerText = "üì° lausche ntfy‚Ä¶";

    ntfyEv.onmessage = (e) => {
      let d = null;
      try { d = JSON.parse(e.data); } catch(err){ return; }
      const msg = d?.message ? String(d.message) : "";
      if (!msg) return;

      // 1) JSON payload support (recommended):
      //    {"title":"...","dance":"Cha-Cha","bpm":31,"meter":"4/4","accent":"1 stark"}
      if (msg.trim().startsWith("{") && msg.trim().endsWith("}")) {
        const obj = safeJson(msg.trim());
        if (obj && (obj.title || obj.dance)) {
          const title = (obj.title || "").trim();
          const dance = (obj.dance || "").trim();
          const bpm   = Number(obj.bpm) || null;
          const meter = (obj.meter || "").trim();
          const accent= (obj.accent || "").trim();

          if (title) UI.song().innerText = title;
          if (dance) UI.dance().innerText = dance;
          if (bpm) UI.bpm().innerText = String(Math.round(bpm));
          if (meter) UI.meter().innerText = meter + " TAKT";
          UI.status().innerText = "üì© ntfy JSON erhalten";

          CAL.lastAi = { title: title || UI.song().innerText, dance, bpm, meter, accent };

          // auto-calibration if enabled
          if (localStorage.getItem("auto_cal") === "1" && CAL.lastAi.bpm && CAL.lastAi.meter) {
            if (!CAL.calibrated) {
              try { CAL.calibrated = false; } catch(e){}
              toggleCalibration();
            } else {
              CAL.targetMeter = CAL.lastAi.meter;
              persistCal();
              applyCalibratedStyle();
            }
          }

          // update history (needs title)
          if (CAL.lastAi.title) {
            pushHistory({
              date: new Date().toISOString(),
              title: CAL.lastAi.title,
              dance: CAL.lastAi.dance || "---",
              bpm: CAL.lastAi.bpm ?? Number(UI.bpm().innerText || 0),
              meter: CAL.lastAi.meter || (UI.meter().innerText.includes("3/4") ? "3/4" : "4/4")
            });
          }
          return;
        }
      }

      // 2) Backwards-compatible text messages:
      // Your watch feed sends either a song title or "üíÉ Dance"
      if (msg.includes("üíÉ")){
        const danceName = msg.replace("üíÉ","").trim();
        if (danceName){
          UI.dance().innerText = danceName;
          UI.status().innerText = "Von Watch: Tanz erhalten";
        }
        return;
      }

      // Otherwise treat as song title update
      UI.song().innerText = msg;
      UI.dance().innerText = "KI PR√úFT‚Ä¶";
      askAI(msg);
    };

    ntfyEv.onerror = () => {
      UI.status().innerText = "ntfy: Verbindung wackelt‚Ä¶";
    };
  } catch(e){
    UI.status().innerText = "ntfy: Fehler";
  }
}
function persistCal(){
  localStorage.setItem(CAL_KEY, JSON.stringify(CAL));
}
function loadCalInternal(){
  try{
    const s = localStorage.getItem(CAL_KEY);
    return s ? JSON.parse(s) : null;
  } catch(e){ return null; }
}

// ========== History + stars
function loadHistoryInternal(){
  try{
    const s = localStorage.getItem(HIST_KEY);
    return s ? JSON.parse(s) : [];
  } catch(e){ return []; }
}
function pushHistory(entry){
  // schema: date,title,dance,bpm,meter
  if (!entry || !entry.title) return;
  HISTORY.unshift({
    date: entry.date,
    title: entry.title,
    dance: entry.dance || "---",
    bpm: Number(entry.bpm) || 0,
    meter: entry.meter || "---"
  });
  HISTORY = HISTORY.slice(0, 200); // cap
  localStorage.setItem(HIST_KEY, JSON.stringify(HISTORY));
  renderHistory();
}
function renderHistory(){
  const tb = document.getElementById("histBody");
  if (!tb) return;
  tb.innerHTML = "";
  for (const h of HISTORY){
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${fmtDate(h.date)}</td>
      <td>${escapeHtml(h.title)}</td>
      <td>${escapeHtml(h.dance)}</td>
      <td>${Math.round(h.bpm||0)}</td>
      <td>${escapeHtml(h.meter)}</td>
    `;
    tb.appendChild(tr);
  }
}
function fmtDate(iso){
  try{
    const d = new Date(iso);
    const dd = String(d.getDate()).padStart(2,"0");
    const mm = String(d.getMonth()+1).padStart(2,"0");
    const yy = d.getFullYear();
    const hh = String(d.getHours()).padStart(2,"0");
    const mi = String(d.getMinutes()).padStart(2,"0");
    return `${dd}.${mm}.${yy} ${hh}:${mi}`;
  } catch(e){ return iso || ""; }
}

function exportHistory(){
  const payload = { version:1, rating, calibration: CAL, history: HISTORY };
  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "tanzdas_history.json";
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
}

function importHistory(ev){
  const f = ev.target.files && ev.target.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    try{
      const obj = JSON.parse(reader.result);
      if (obj.history) {
        HISTORY = obj.history;
        localStorage.setItem(HIST_KEY, JSON.stringify(HISTORY));
      }
      if (obj.calibration) {
        CAL = obj.calibration;
        persistCal();
        applyCalibratedStyle();
      }
      if (typeof obj.rating === "number") {
        rating = obj.rating;
        localStorage.setItem(RATING_KEY, String(rating));
        renderStars();
      }
      renderHistory();
      alert("Import OK ‚úÖ");
    } catch(e){
      alert("Import fehlgeschlagen.");
    }
  };
  reader.readAsText(f);
  ev.target.value = "";
}

function clearHistory(){
  if (!confirm("Historie wirklich l√∂schen?")) return;
  HISTORY = [];
  localStorage.setItem(HIST_KEY, JSON.stringify(HISTORY));
  renderHistory();
}

function renderStars(){
  const wrap = document.getElementById("stars");
  if (!wrap) return;
  wrap.innerHTML = "";
  for (let i=1;i<=5;i++){
    const s = document.createElement("div");
    s.className = "star" + (i<=rating ? " on" : "");
    s.textContent = "‚òÖ";
    s.onclick = () => {
      rating = i;
      localStorage.setItem(RATING_KEY, String(rating));
      renderStars();
    };
    wrap.appendChild(s);
  }
}

// ========== Help videos UI
function renderHelpVideos(){
  const body = document.getElementById("helpBodyVideos");
  if (!body) return;
  body.innerHTML = "";

  for (const dance of VIDEO_DB){
    const det = document.createElement("details");
    det.className = "danceCard";
    det.open = true;

    const sum = document.createElement("summary");
    sum.innerHTML = `<span>${escapeHtml(dance.title)}</span><span style="opacity:.65;font-weight:700;">${dance.figures.length} Figuren</span>`;
    det.appendChild(sum);

    for (const fig of dance.figures){
      const row = document.createElement("div");
      row.className = "figRow";

      const head = document.createElement("div");
      head.className = "figHead";

      const name = document.createElement("div");
      name.className = "figName";
      name.textContent = fig.name;

      const btn = document.createElement("button");
      btn.className = "miniBtn blue";
      btn.textContent = "Abspielen (Loop)";
      btn.onclick = () => {
        const wrap = row.querySelector(".playerWrap");
        HelpPlayer.playSegment(dance.src, fig.start, fig.end, wrap);
      };

      head.append(name, btn);

      const wrap = document.createElement("div");
      wrap.className = "playerWrap";

      row.append(head, wrap);
      det.appendChild(row);
    }

    body.appendChild(det);
  }
}

// ========== Tap tempo
function tapPad(ev, kind){
  ev.preventDefault();

  // pressure (0..1) if available
  const p = (typeof ev.pressure === "number" && ev.pressure > 0) ? ev.pressure : 0.5;
  const now = performance.now();
  tapTimes.push({ t: now, p, kind });
  if (tapTimes.length > 24) tapTimes.shift();

  updateTapEstimate();
}

function updateTapEstimate(){
  if (tapTimes.length < 6) return;

  // take last 10 taps
  const xs = tapTimes.slice(-10).map(x => x.t);
  const intervals = [];
  for (let i=1;i<xs.length;i++) intervals.push(xs[i]-xs[i-1]);
  intervals.sort((a,b)=>a-b);
  const med = intervals[Math.floor(intervals.length/2)];
  if (!isFinite(med) || med<=0) return;

  const rawBpm = 60000/med;
  const { bpm } = normalizeBpm(rawBpm); // uses calibration if set
  const bpmR = Math.round(bpm);

  document.getElementById("tapBpm").innerText = bpmR;
  document.getElementById("tapMeter").innerText = tapMeter;

  const dance = pickDance(bpmR, tapMeter);
  document.getElementById("tapDance").innerText = dance;
}

function setTapMeter(m){
  tapMeter = m;
  document.getElementById("tapMeter").innerText = tapMeter;
  updateTapEstimate();
}
function resetTap(){
  tapTimes = [];
  document.getElementById("tapBpm").innerText = "‚Äî";
  document.getElementById("tapDance").innerText = "‚Äî";
}

// ========== Utilities
function requestFullscreenSafe(video){
  if (!video) return;
  if (video.requestFullscreen) video.requestFullscreen();
  else if (video.webkitEnterFullscreen) video.webkitEnterFullscreen();
}
function fmtTime(sec){
  sec = Math.max(0, Number(sec)||0);
  const m = Math.floor(sec/60);
  const s = Math.floor(sec%60);
  return `${m}:${String(s).padStart(2,"0")}`;
}
function escapeHtml(str){
  return String(str||"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

// ========== AI connectivity test
async function testAI() {
  const key = UI.apiKey().value;
  if (!key) { alert("Key fehlt!"); return; }
  try {
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${key}`},
      body: JSON.stringify({model: "gpt-4o-mini", messages: [{role: "user", content: "Hi"}], max_tokens: 5})
    });
    if (resp.status === 200) alert("Verbindung OK! ‚úÖ");
    else alert("Fehler: " + resp.status);
  } catch (e) { alert("Netzwerkfehler"); }
}
</script>

</body>
</html>